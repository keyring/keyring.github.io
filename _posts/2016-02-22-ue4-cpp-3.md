---
data: 2016-02-22
layout: post
title: UE4中C++编程 III
categories: UE4
tags: note
---


之前说过，UE4对C++进行了扩展增强，使其便于游戏开发。下面就简要介绍增加的特性。


---------------------------------------
##反射系统（Unreal Reflection System）

内置的逻辑类利用了特殊的标记，所以先概览一下Unreal的原型系统。UE4自己实现了一套反射系统，动态支持诸如垃圾回收、序列化、网络复制、Blueprint/C++通讯等特性。这些特性是可选的，意味着你必须先给你的类型加上标记才能使用，不然Unreal不会给它们生成反射数据。下面列了几个基本的标记：

- **UCLASS()** － 为**class**生成反射数据。该类必须是派生于`UObject`。
- **USTRUCT()** － 为**struct**生成反射数据。
- **GENERATED_BODY() － UE4会在此换成为该类型生成的模版代码。
- **UPROPERTY()** － 让UCLASS/USTRUCT中的成员变量作为UPROPERTY。UPROPERTY可让变量用于复制、序列化并从Blueprint中可访问，同时受垃圾回收器追踪。
- **UFUNCTION()** － 让UCLASS/USTRUCT中的成员方法作为UFUNCTION。UFUNCTION可让方法从Blueprint中调用，用作RPCs等等。


举个代码示例：

```cpp
#include "MyObject.generated.h"

UCLASS(Blueprintable)
class UMyObject : public UObject
{
    GENERATED_BODY()

public:
    MyUObject();

    UPROPERTY(BlueprintReadOnly, EditAnywhere)
    float ExampleProperty;

    UFUNCTION(BlueprintCallable)
    void ExampleFunction();
};
```

先注意头文件`"MyObject.generated.h"`，Unreal生成的所有反射数据都在此文件里。需要把该文件包括在头文件列表最末。

标记里带有说明符，用于明确指定类型的行为。

- **Blueprintable** － 该类暴露给 Blueprint
- **BlueprintReadOnly** － 该属性在Blueprint中只读不可写
- **Category** － 确定该属性在编辑器的详细面板中显示在哪个分类下，方便管理
- **BlueprintCallable** － Blueprint中可调用该函数

引擎里说明符非常多，分类查阅参考：

- [UCLASS说明符](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Classes/Specifiers/index.html)
- [UPROPERTY说明符](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html)
- [UFUNCTION说明符](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Functions/Specifiers/index.html)
- [USTRUCT说明符](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Structs/Specifiers/index.html)


至于反射系统更详细的解读，比如其实现原理之类的，参阅[官方博客](https://www.unrealengine.com/blog/unreal-property-system-reflection)


---------------------------------
##Object/Actor 迭代器

object迭代器用于遍历一个UObject类型的所有实例（子类）时还是很方便有用的。

```cpp
// Will find ALL current UObjects instances
for (TObjectIterator<UObject> It; It; ++It)
{
    UObject* CurrentObject = *It;
    UE_LOG(LogTemp, Log, TEXT("Found UObject named: %s"), *CurrentObject.GetName());
}
```

给迭代器提供范围时，注意该类型需要派生自`UObject`，假设你有个派生于UObject的类叫`UMyClass`，使用迭代器，可以遍历其所有实例（与子类）：

```cpp
for (TObjectIterator<UMyClass> It; It; ++It)
{
    // ...
}
```


actor迭代器用法和object迭代器一样，但只能用于派生自`AActor`的对象。返回的只有当前游戏实例中使用的对象。所以，使用actor迭代器时，需要提供一个`UWorld`实例。大部分UObject类比如`APlayerController`都提供**`GetWorld`**方法来方便获取。如果不确定，还可以先用`ImplementsGetWorld`方法检查一下该UObject对象是否实现了`GetWorld`方法。

```cpp
APlayerController* MyPC = GetMyPlayerControllerFromSomewhere();
UWorld* World = MyPC->GetWorld();

// Like object iterators, you can provide a specific class to get only objects that are
// or derive from that class
for (TActorIterator<AEnemy> It(World); It; ++It)
{
    // ...
}
```


----------------------------
##内存管理与垃圾回收

介绍点UE4中基本的内存管理机制和垃圾回收系统。

###UObjects与垃圾回收


------------------
###Actors与垃圾回收



-----------------------
###UStructs


---------------------------
###非UObject引用






-----------------------------
##类名的前缀



-----------------------------
##数值类型


------------------------------
##字符串


###FString


------------------
###FText



------------------
###FName



------------------------
###TCHAR




----------------------
##容器


###TArray




------------------------
###TMap




---------------------------
###TSet




----------------------------
###容器迭代器



------------------------
###For-each循环




-----------------------------
###TSet/TMap作用于自定义类型）
