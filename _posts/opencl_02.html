<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>opencl_02</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<hr />
<p>data: 2013-10-28 
layout: post
title: OpenCL学习笔记——基本术语解释（一）
categories: opencl</p>
<h2>tags: opencl note gpgpu</h2>
<p>我们在做 OpenCL 编程时，会先做很多环境设定。上一篇的示例程序中，出现了诸如 platform，context，device，kernel，buffer 等等术语。这些对于以前做过图形编程的开发人员来说，见之会心一笑。而对其他人来说则莫名其妙。所以，这篇文章来详细讲解一下这些术语。当然，不足之处在所难免，一切以 <code>OpenCL Specification</code> 为准。</p>
<ul>
<li><strong><a href="#platform">platform</a></strong></li>
<li><strong><a href="#device">device</a></strong></li>
<li><strong><a href="#context">context</a></strong></li>
<li><strong><a href="#jie">总结</a></strong></li>
</ul>
<hr />
<h2><span id="platform"> platform </span></h2>
<p>OpenCL 全称 Open Computing Language，作为开放语言自然有其开放的特质。其为异构平台提供了一个编写程序，尤其是并行程序的开放式框架标准。它支持的异构平台可由多核 CPU、GPU 或其他类型的处理器（DSP）组成。</p>
<p>这个框架标准具体来说就是 <strong><code>platform</code></strong>。OpenCL 使用的是 Installable Client Driver,ICD 模型，意味着一个系统上可以有多个 OpenCL 实现并存。简单地说，你的系统上有多少个 OpenCL 框架/实现/ platform，取决于你有什么硬件和与之配对的驱动程序。比如，我的系统是 Windows+Intel处理器+AMD显卡，所以装好显卡驱动后，我的PC上就有两个 OpenCL 框架/实现/platform，如果你再装个 NVIDIA 显卡和驱动，那就又多了一个 platform。例外的是苹果电脑，由于它的封闭统一性，便只有一个 OpenCL platform。</p>
<p>到此，我们可以明白，<strong><code>platfrom</code> == <code>implement</code></strong>，你的系统上有多少个 OpenCL 实现，就有多少个 <code>platform</code>。一般具体的实现都在驱动程序里面，所以千万记得装好对应的驱动程序！</p>
<p>我们可以通过 <code>clGetPlatformIDs</code> 来查询 platform 集。</p>
<pre><code>cl_int clGetPlatformIDs( cl_uint        num_entries,
                         cl_platform_id *platforms,
                         cl_uint        *num_platforms )
</code></pre>

<p>这类查询函数在 OpenCL 里用法相似。两次调用，第一次获取<strong>结果的个数/大小</strong>以便申请内存空间，第二次调用来获取具体的<strong>结果集</strong>。</p>
<p>举个例子来说明一下：</p>
<pre><code>cl_int status;                  // 获取函数返回值，一般是状态码
cl_uint numPlatforms;           // platfrom 数量 
cl_platform_id *platormIds;     // 存储所有 platform 的空间

// 第一次调用，获取 platform 个数
status = clGetPlatformIDs( 0, NULL, &amp;numPlatforms );

// 利用获取的个数来申请内存空间
platformIds = (cl_platform_id *)alloca(sizeof(cl_platform_id) * numPlatforms);

// 第二次调用，获取 platform ID 列表
status = clGetPlatformIDs( numPlatforms, platformIds, NULL );
</code></pre>

<p><strong>注意：对于苹果系统，这一步没有必要，因为 MAC 上只有一个 platform。</strong></p>
<p>在已知了 <code>platform</code> 之后，可以通过 <code>clGetPlatformInfo</code> 函数来获取 platform 的各个属性。</p>
<pre><code>cl_int clGetPlatformInfo( cl_platform_id    platform,
                          cl_platform_info  param_name,
                          size_t            param_value_size,
                          void              *param_value,
                          size_t            *param_value_size_ret )
</code></pre>

<p>其中 <code>param_name</code> 的取值如下：</p>
<pre><code>-CL_PLATFORM_PROFILE        // OpenCL 简档
-CL_PLATFORM_VERSION        // OpenCL 版本
-CL_PLATFORM_NAME           // platform 名字
-CL_PLATFORM_VENDOR         // platform 开发商
-CL_PLATFORM_EXTENSIONS     // platform 支持的扩展列表

// 它们的返回值都是 字符串。
</code></pre>

<p>该 API 的具体使用请参考 <code>OpenCL Specification</code>。</p>
<hr />
<h2><span id="device"> device </span></h2>
<p>如果说 <code>platform</code> 只是一个框架实现，看得见摸不着。那么 <strong><code>device</code></strong> 就是一个非常具体的存在了。简单地说，<strong><code>device</code> 就是硬件设备</strong>，比如 CPU,GPU。你的应用程序将利用这些计算设备来执行代码。</p>
<p>各个 platform 可能会分别关联一组计算设备。在给定的 platform 上，可以使用 <code>clGetDeviceIDs</code> 来获取与之关联的受支持的设备列表。</p>
<pre><code>cl_int clGetDeviceIDs( cl_platform_id   platform,
                       cl_device_type   device_type,
                       cl_uint          num_entries,
                       cl_device_id     *devices,
                       cl_uint          *num_devices )
</code></pre>

<p>其中 <code>device_type</code> 代表你获取的设备的类型，其取值如下：</p>
<pre><code>-CL_DEVICE_TYPE_CPU // host 端的 CPU 设备
-CL_DEVICE_TYPE_GPU // GPU 设备
-CL_DEVICE_TYPE_ACCELERATOR // OpenCL 加速器
-CL_DEVICE_TYPE_DEFAULT // 默认设备
-CL_DEVICE_TYPE_ALL // 与相应 platform 关联的所有设备
</code></pre>

<p><strong><code>CPU</code></strong>是一个同构设备，通常可以利用大缓存进行优化来减少延迟。比如 AMD 的 Opteron 系列和 Intel 的 Core 系列。</p>
<p><strong><code>GPU</code></strong>是面向图形和通用计算的大吞吐量设备。比如 AMD 的 Radeon 系列和 NVIDIA 的 GTX 系列。</p>
<p><strong><code>ACCELERATOR</code></strong>涵盖了从 IBM 的 Cell Broadband 体系结构到不太著名的 DSP 型等大量的设备。</p>
<p><strong><code>DEFAULT</code></strong>允许 OpenCL Running time library 指定一个“首选”设备。</p>
<p><strong><code>ALL</code></strong>允许 OpenCL Running time library 指定所有可用设备。</p>
<p>对于 <code>CPU</code>,<code>GPU</code> 和 <code>ACCELERATOR</code> 设备，对 platform 提供的设备数量没有任何限制，由应用程序负责查询来确定具体的数目。当然，使用的 API 还是 <code>clGetDeviceIDs</code>。</p>
<p>对于获取的某个 <code>device</code>，可以利用 <code>clGetDeviceInfo</code> 函数查询其各项属性：</p>
<pre><code>cl_int clGetDeviceInfo( cl_device_id device,
                        cl_device_info param_name,
                        size_t param_value_size,
                        void *param_value,
                        size_t *param_value_size_ret )
</code></pre>

<p>这个函数能够返回的信息非常多,大概好几十种吧，从设备类型到设备的内存状态均能获得。具体的请查阅 <code>OpenCL Specificaion</code>。至于函数的使用，咱们以后在具体示例中来展现。</p>
<hr />
<h2><span id="context"> context <span></h2>
<p><code>context</code> 是所有 OpenCL 应用的核心。它为与之关联的 <code>device</code>,<code>memory</code>,<code>command queue</code> 提供一个<strong>容器</strong>。如果说 <code>platform</code> 等于 <strong>实现</strong>，<code>device</code> 就是 <strong>设备</strong>，那么 <code>context</code> 就是一个 <strong>管理员</strong>。它管理着应用程序与设备，设备与设备之间的通信。</p>
<p>正如 <code>platform</code>,<code>device</code> 有很多个一样，<code>context</code> 也可以有很多个。不同之处在于，前面两个的个数我们没法控制，是硬件/软件提供商提供的，而 <code>context</code> 是由我们自己决定的。</p>
<p>我们可以由不同的 <code>platform</code> 创建多个 <code>context</code>，并把工作分布到这些 <code>context</code> 和与之关联的 <code>device</code> 上。下面这幅图可以直观的展示它们之间的关系，简单的说，都是 <strong>一对多</strong> 的关系。</p>
<p><img src="image/opencl_02_01.png" /></p>
<p><code>context</code> 不再由别人提供，需要我们自己来创建。有两种方式来创建：已知一个 <code>platform</code> 和一组关联的 <code>device</code>，可以使用 <code>clCreateContext</code> 函数来创建；已知一个 <code>platform</code> 和 <code>device</code> 的类型，可以使用 <code>clCreateContextFromType</code> 函数来创建。</p>
<pre><code>cl_context clCreateContext( const cl_context_properties *properties,
                            cl_uint num_devices,
                            const cl_device_id *devices,
                            void (CL_CALLBACK *pfn_notify)( const char *errorinfo,
                                                            const void *private_info,
                                                            size_t cb,
                                                            void *user_data ),
                            void *user_data,
                            cl_int *errcode_ret )


cl_context clCreateContextFromType( const cl_context_properties *properties,
                                    cl_device_type device_type,
                                    void (CALLBACK *pfn_notify) (const char *errinfo,
                                                                 const void *private_info,
                                                                 size_t cb,
                                                                 void *user_data),
                                    void *user_data,
                                    cl_int *errcode_ret )
</code></pre>

<p>参数 <code>pfn_notify</code> 和 <code>user_data</code> 用来共同定义一个回调，用于报告 context 生命期中所出现错误的有关信息，记得把 <code>user_data</code> 最为最后一个参数传给回调函数。</p>
<p>同样的，我们也可以通过 API 来查询 <code>context</code> 的属性，<code>clGetContextInfo</code> 函数的具体用法将在以后的示例程序里展现。</p>
<pre><code>cl_int clGetContextInfo( cl_context         context,
                         cl_context_info    param_name,
                         size_t             param_value_size,
                         void               *param_value,
                         size_t             *param_value_size_ret )
</code></pre>

<p>所有的 OpenCL 对象都是引用计数的，对于 <code>context</code> 这类有我们自己创建的对象，需要我们自己来递增和递减引用数。</p>
<pre><code>cl_int clRetainContext (cl_context context)     // 递增引用数
cl_int clReleaseContext(cl_context context)     // 递减引用数
</code></pre>

<hr />
<h2><span id="jie"> 总结 </span></h2>
<p>废话了这么多，简单而粗略的总结：</p>
<ul>
<li><strong>platform： OpenCL 框架/实现</strong></li>
<li><strong>device： 运行 OpenCL 程序的具体硬件设备</strong></li>
<li><strong>context： 管理 device 与 OpenCL 程序的容器</strong></li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
