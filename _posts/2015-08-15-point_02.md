---
data: 2015-8-15
layout: post
title: point renderer 2
categories: point
tags: graphics note
---

点线面

画线算法解决的是数学上没有宽度大小的直线如何映射到像素矩阵中。数学上的直线是由没有大小的点必须映射到显示器的像素单位上。以像素为单位，则整个显示范围其实是一个整数区间。于是，一些数学计算出来的小数像素要具体落到哪些像素上，就需要这些个画线算法来决定。而其最基本最原始的方案就是就近原则。即理想点与哪个像素近就取那一个。怎么来找这个最近的像素，还要尽可能的快找到？如何评判快慢，计算机指令越少越简单就越快。请看下面最著名的三种算法。

选取基准变量，基准量每次增长一个像素，另一个要么不变，要么增长。不变还是增长取决于理想点的y到底离谁更近。所以有四舍五入法，也有中点判断法。求直线还得利用两个数学公式。说到底啊，还是在用计算机hack数学公式。


dda画线算法

四舍五入型

这个算法hack的是斜截式直线方程 y = kx + b。根据斜率，分别算出固定的步进长度，然后逐步逼近终点，在x和y的确定上，使用的是**四舍五入**法。利用了计算机浮点数与整数的截断操作。这算是直接求点型。

```c


void line_dda(struct point start, struct point end, struct color line_color, struct paint *painter)
{
    int dx = end.x - start.x;
    int dy = end.y - start.y;

    int steps = abs(dx) >= abs(dy) ? abs(dx) : abs(dy);

    float xi = (float)dx / steps;
    float yi = (float)dy / steps;

    float x = (float)start.x + 0.5; //加0.5是为了四舍五入
    float y = (float)start.y + 0.5;
    for(int i = 0; i <= steps; i++){
        pixel((int)x, (int)y, line_color, painter);
        x += xi;
        y += yi;
    }
    
}

```c

midpoint画线算法

这个算法hack的是一般式直线方程 ax + by + c = 0。但他不直接利用该公式求x和y，而是根据像素排列规则（整数，矩形）来决定x和y是不变还是增加1。具体做法就是将待选的两个像素的**中点**代入方程做计算，结果只有三种，等于0，小于0，大于0。

```c

if(d == 0)
    // 两个备选点离理想点距离一样，随便取一个即可
else if(d < 0)
    // 中点在理想点下面，即上面那个备选点离理想点更近，取之
else
    // 中点在理想点上面，即下面那个备选点离理想点更近，取之

```c

一般的教科书示例代码只描述了以x为基准量且终点位于起点的第一象限内的情况。还有其它7种情况。
